#!/usr/bin/env python3
import os
import csv
import sys
import time
from rosbag2_py import SequentialReader, StorageOptions, ConverterOptions
from rclpy.serialization import deserialize_message
from ament_index_python.packages import get_package_share_directory
from rosidl_runtime_py.utilities import get_message

from interfaces.msg import *

"""
    This script reads a bag file generated by the machpilot project and produces a .csv file for each topic.
    Warning: This is not optimized and may take a very long amount of time.

    Usage:
        python3 bag_to_csv.py <bag_file>

"""

def flatten_ros_message(msg, prefix=""):
    """
        Recursive method that takes a ros2 message and turns it into a dictionary that can be easily written to a csv file.
    """

    flat = {} # Dictionary to store the flattened message
    if hasattr(msg, "_fields_and_field_types"): # every message should have fields in it (assuming it's not empty)
        for field, _ in msg._fields_and_field_types.items(): # loop through every field in the message
            value = getattr(msg, field)
            full_field = f"{prefix}{field}" if not prefix else f"{prefix}.{field}"

            if hasattr(value, "_fields_and_field_types"): # if this field is a message, then do recursive call
                flat.update(flatten_ros_message(value, prefix=full_field))

            elif isinstance(value, (list, tuple)) and value and hasattr(value[0], "_fields_and_field_types"): # it could also be a list of messages
                for idx, item in enumerate(value):
                    flat.update(flatten_ros_message(item, prefix=f"{full_field}[{idx}]"))
            else: # or it's just a value
                flat[full_field] = value
    else: 
        for field in getattr(msg, "__slots__", []):
            full_field = f"{prefix}{field}" if not prefix else f"{prefix}.{field}"
            flat[full_field] = getattr(msg, field)
    
    return flat
        

def bag_to_csv(bag_path):

    print("Converting bag file to csv files... This may take a while.")

    # Configure options
    storage_options = StorageOptions(uri=bag_path)
    converter_options = ConverterOptions("","")
    reader = SequentialReader()
    reader.open(storage_options, converter_options)

    topics_metadata = reader.get_all_topics_and_types()
    csv_writers = {}
    header_written = set()

    while reader.has_next():
        (topic_name, data, timestamp) = reader.read_next()

        topic_meta = next((t for t in topics_metadata if t.name == topic_name), None)

        if topic_meta is None:
            sys.stderr.write(f"Could not find metadata for topic {topic_name}\n")
            continue

        try:
            msg_class = get_message(topic_meta.type)
        except Exception as e:
            sys.stderr.write(f"Could not find message class for topic {topic_name}\n")
            sys.stderr.write(f"Did you run source install/setup.bash?\n")
            continue

        try:
            msg = deserialize_message(data, msg_class)
        except Exception as e:
            sys.stderr.write(f"Could not deserialize message for topic {topic_name}\n")
            continue

        flat_msg = flatten_ros_message(msg)

        if topic_name not in csv_writers:
            csv_filename = os.path.join(bag_path, topic_name.strip("/").replace("/", "_") + ".csv")
            csv_file = open(csv_filename, "w")        
            writer = csv.writer(csv_file)
            header = ["timestamp"] + sorted(flat_msg.keys())
            writer.writerow(header)
            csv_writers[topic_name] = (writer, csv_file)
            header_written.add(topic_name)

        writer, _ = csv_writers[topic_name]
        row = [timestamp] + [flat_msg[key] for key in sorted(flat_msg.keys())]
        writer.writerow(row)

    for writer, csv_file in csv_writers.values():
        csv_file.close() 

    print("Conversion complete.")



if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python3 bag_to_csv.py <bag_path>")
        sys.exit(1)

    bag_path = sys.argv[1]

    # Create a directory to store the csv files
    if not os.path.exists(bag_path):
        print("Bag file not found.")
        sys.exit(1)

    bag_to_csv(bag_path)